# 11장 클라이언트 식별과 쿠키

HTTP는 기본적으로 **"상태가 없는(stateless)"** 프로토콜이라, 각 요청과 응답이 독립적으로 처리됩니다.

하지만 현대 웹사이트에서는 **개인화된 서비스 제공**과 **사용자 추적**을 위해 클라이언트를 식별하는 다양한 기술이 필요합니다.

-----

### 개별 접촉의 필요성

> 웹 서버가 익명의 요청뿐만 아니라 서버와 통신하는 **클라이언트를 추적**하기 위해 사용하는 다양한 기술들의 집합입니다.

현대 웹사이트에서 개인화된 서비스를 제공해야 하는 필요성은 다음과 같습니다.

  * **개별 인사**: 사용자에게 특화된 환영 메시지나 페이지를 제공합니다.
  * **사용자 맞춤 추천**: 고객의 흥미에 맞는 제품을 추천해 드립니다.
  * **저장된 사용자 정보**: 배송 주소, 신용카드 정보 등을 저장하여 편의성을 제공합니다.
  * **세션 추적**: 상태를 유지하며 사용자와 상호작용합니다 (예: 장바구니 기능).

-----

### HTTP 헤더를 통한 식별 정보

> 사용자에 대한 정보를 전달하는 HTTP 헤더들로, 브라우저가 서버에 요청을 보낼 때 **자동으로 포함되는 정보**들입니다.

#### 주요 식별 관련 헤더

| 헤더 이름 | 포함되는 정보 | 참고 사항 |
| :--- | :--- | :--- |
| `From` | 사용자의 이메일 주소 | 스팸 우려로 **대부분 사용하지 않습니다**. |
| `User-Agent` | 사용자의 브라우저와 운영체제 정보 | |
| `Referer` | 사용자가 현재 링크를 타고 온 이전 페이지의 URL | 오타가 아닌 표준 명칭입니다. |
| `Authorization` | 사용자 이름과 비밀번호 | 로그인 정보입니다. |
| `Client-IP`/`X-Forwarded-For` | 클라이언트의 IP 주소 | |
| `Cookie` | 서버가 생성한 ID 라벨 | 현재 가장 널리 사용됩니다. |

-----

### 클라이언트 IP 주소 기반 식별

초기에는 클라이언트의 IP 주소를 이용하여 사용자를 식별하려 했으나 여러 **한계점**이 존재합니다.

#### 한계점

  * IP 주소는 사용자가 아닌 **컴퓨터를 식별**합니다 (다수 사용자가 한 기기 사용 시 구분 불가).
  * 많은 ISP는 **동적 IP 할당** 방식을 사용하여 접속할 때마다 IP가 변경될 수 있습니다.
  * **NAT**나 **방화벽** 사용 시 실제 IP 주소가 숨겨집니다.
  * **프락시 서버** 사용 시 서버는 프락시의 IP만 확인할 수 있습니다.

일부 프락시는 `Client-IP`나 `X-Forwarded-For`와 같은 확장 헤더로 원본 IP 보존을 시도하지만 모든 프락시가 이를 지원하지는 않습니다.

-----

### 사용자 로그인 기반 식별

> 사용자 이름과 비밀번호로 인증(로그인)하여 **명시적으로 사용자를 식별**하는 방식입니다.

HTTP는 `WWW-Authenticate`와 `Authorization` 헤더를 통해 로그인 기능을 제공합니다.

#### 로그인 과정

1.  사용자가 보호된 리소스를 요청하면, 서버는 **401 응답**과 함께 `WWW-Authenticate` 헤더를 전송합니다.
2.  브라우저가 로그인 **대화상자를 표시**합니다.
3.  사용자가 정보를 입력하면, 브라우저는 `Authorization` 헤더에 **자격증명을 추가**하여 재요청합니다.
4.  이후 동일 사이트 요청 시 브라우저가 자동으로 인증 정보를 전송합니다.

#### 문제점

  * 사이트마다 **별도의 로그인**이 필요합니다.
  * 다양한 사용자명/비밀번호 조합을 **기억**해야 합니다.
  * 각 사이트마다 **다른 규칙과 제약**이 존재할 수 있습니다.

-----

### 뚱뚱한 URL (Fat URL)

> URL에 사용자 식별 정보나 세션 정보를 포함시키는 기술로, 주로 경로 처음이나 끝에 **상태 정보를 추가**하는 방식입니다.

#### 특징

  * URL에 사용자 상태 정보나 식별자를 포함합니다 (예: `/exec/obidos/tg/browse/-/229220/002-1145265-8016838`).
  * 서버가 페이지의 모든 링크를 **동적으로 생성**하여 식별 정보를 유지합니다.

#### 단점

  * **심미적 문제**: 복잡하고 혼란스러운 URL이 생성됩니다.
  * **공유 문제**: URL 공유 시 **개인 정보 노출** 위험이 있습니다.
  * **캐싱 불가**: 동일 페이지도 URL 변경으로 **캐싱이 어렵습니다**.
  * **서버 부하**: 모든 페이지와 링크를 동적으로 생성해야 합니다.
  * **이탈 위험**: 사용자가 다른 사이트로 이동하거나 일반 URL 사용 시 세션 정보가 손실됩니다.
  * **세션 지속성 부재**: 로그아웃 시 모든 정보가 손실됩니다.

이러한 문제들을 해결하는 더 효율적인 식별 기술이 바로 '쿠키'입니다.

-----

### 쿠키

> 사용자를 식별하고 세션을 유지하는 방식 중에서 **현재까지 가장 널리 사용**하는 방식입니다. 넷스케이프가 최초 개발했고 현재는 모든 브라우저에서 지원합니다.

참고: 쿠키는 캐시와 충돌할 수 있어, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 **캐싱하지 않습니다**.

#### 쿠키의 타입

**세션 쿠키**와 **지속 쿠키** 두 가지 타입으로 구분됩니다.

  * **세션 쿠키**: 사용자가 사이트를 탐색할 때 관련 설정과 선호 사항을 저장하는 **임시 쿠키**로, **브라우저 종료 시 삭제**됩니다.
  * **지속 쿠키**: **디스크에 저장**되어 브라우저 종료나 컴퓨터 재시작 후에도 유지되는 쿠키로, 주기적 방문 사이트의 설정이나 로그인 정보 유지에 사용됩니다.

쿠키는 `Discard` 파라미터가 설정되어 있거나 `Expires`/`Max-Age` 파라미터가 없으면 세션 쿠키가 됩니다.

#### 쿠키 동작 원리

서버가 사용자에게 붙이는 스티커/라벨과 같은 역할을 수행합니다.

1.  최초 방문 시 웹 서버는 사용자에 대해 아무것도 모릅니다.
2.  서버는 사용자 식별을 위한 **유일값**을 쿠키에 할당합니다.
3.  브라우저는 쿠키를 **데이터베이스에 저장**합니다.
4.  이후 방문 시 브라우저는 서버가 할당한 쿠키를 **`Cookie` 요청 헤더에 포함**하여 전송합니다.

쿠키는 단순 ID 번호뿐 아니라 다양한 정보(이름, 전화번호 등)를 포함할 수 있습니다.

#### 쿠키 상자: 클라이언트 측 상태

쿠키의 기본 발상은 브라우저가 서버 관련 정보를 저장하고, 해당 서버 접근 시 그 정보를 함께 전송하는 것입니다. 공식적으로는 'HTTP 상태 관리 체계'라 불립니다.

  * **브라우저별 쿠키 저장 방식**:
      * **구글 크롬**: **SQLite 파일**에 쿠키 저장 (`host_key`, `name`, `value`, `expire_utc` 등의 정보 포함)
      * **인터넷 익스플로러**: 각각의 **개별 파일**로 쿠키 저장

#### 사이트별 쿠키 관리

브라우저는 수백/수천 개의 쿠키를 가질 수 있으나, 모든 사이트에 모든 쿠키를 전송하지는 않습니다. 일반적으로 각 사이트에 **2\~3개의 쿠키만 전송**합니다.

  * 모든 쿠키 전달 시 **성능 저하**가 발생합니다.
  * 대부분 쿠키는 **특정 서버에 특화된 값**을 포함합니다.
  * 모든 쿠키를 모든 사이트에 전달 시 **개인정보 문제**가 발생할 수 있습니다.

**쿠키 도메인 제어**를 통해 이를 관리합니다.

  * **`Domain` 속성**: 서버가 `Set-Cookie` 응답 헤더에 기술하여 **어떤 사이트가 쿠키를 읽을 수 있는지 제어**합니다.
  * **`Path` 속성**: URL 경로 앞부분을 지정하여 **웹사이트 일부에만 쿠키를 적용**할 수 있습니다.

따라서 쿠키는 일종의 **상태 정보**이며, 서버가 생성해 클라이언트에 전달하고, 클라이언트는 그 쿠키를 유효한 사이트에만 다시 전달하고 관리합니다.

#### 쿠키 구성요소

현재 Version 0 (넷스케이프 쿠키)와 **Version 1 (RFC 2965)** 쿠키 명세가 존재합니다. Version 1은 Version 0의 확장이나 널리 사용되지는 않습니다.

#### Version 0 (넷스케이프) 쿠키 형식/명세

  * 서버 응답 헤더:
    ```
    Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
    ```
  * 클라이언트 요청 헤더:
    ```
    Cookie: name1=value1 [; name2=value2] ...
    ```

#### `Set-Cookie` 헤더 속성

| 속성 | 필수/선택 | 설명 | 예시 |
| :--- | :--- | :--- | :--- |
| **이름=값** | **필수** | 쿠키의 이름과 값 (세미콜론, 쉼표, 등호, 공백 미포함) | `Set-Cookie: customer=Mary` |
| `Expires` | 선택적 | 쿠키의 **파기 일자**를 GMT로 기술합니다. 미지정 시 세션 쿠키입니다. | `expires=Wednesday, 09-Nov-99 23:12:40 GMT` |
| `Domain` | 선택적 | 이 속성에 기술된 **도메인 사용 서버로만** 쿠키를 전송하도록 제한합니다. 미지정 시 응답 생성 서버 호스트명이 기본값입니다. | `domain="joes-hardware.com"` |
| `Path` | 선택적 | 서버의 **특정 문서 경로**에만 쿠키를 할당합니다. 미지정 시 응답 URL의 경로가 사용됩니다. | `path=/orders` |
| `Secure` | 선택적 | 이 속성 포함 시 **SSL 보안 연결일 때만** 쿠키를 전송합니다. | `secure` |

#### Version 0 `Cookie` 헤더

클라이언트가 서버에 요청 시, 현재 요청 사이트와 일치하는 **`Domain`**, **`Path`**, **`Secure`** 필터를 가지면서 아직 파기되지 않은 모든 쿠키를 `Cookie` 헤더에 포함시켜 전송합니다.

예: `Cookie: session-id=002-1145265-8016838; session-id-time=1007884800`

-----

### Version 1 쿠키 (RFC 2965)

> 넷스케이프 표준보다 복잡하고 확장된 쿠키 버전으로, \*\*`Set-Cookie2`\*\*와 **`Cookie2`** 헤더를 도입했으나 **현재는 폐기되어 더 이상 지원되지 않습니다**.

#### 주요 추가사항

  * 쿠키 목적을 설명하는 **설명문** 제공
  * 브라우저 종료 시 **강제 삭제 기능**
  * **초 단위 상대값** 기반 생명주기 (`Max-Age`) 설정
  * **포트번호 제어** 가능
  * 필터 정보에 **$ 접두어** 사용

-----

### 쿠키와 세션 추적

> 여러 트랜잭션에 걸쳐 **사용자를 식별하는 메커니즘**으로, 전자상거래 사이트의 **쇼핑 카트 유지** 등에 활용됩니다.

Amazon.com 사례처럼, 초기 접속 시 **연속적 리다이렉트와 쿠키 설정** 과정을 통해 사용자를 추적하며, 클라이언트가 쿠키를 미지원할 경우 **뚱뚱한 URL**로 대체되기도 했습니다.

-----

### 쿠키와 캐싱

> [\!NOTE]
> 쿠키가 포함된 트랜잭션의 부적절한 캐싱은 **개인정보 노출** 등 심각한 문제를 초래할 수 있습니다.

#### 캐싱 관련 주의사항

  * 캐시 가능 여부를 **명시적으로 표시**해야 합니다.
  * `Cache-Control: **no-cache="Set-Cookie"**` 사용을 권장합니다.
  * `Set-Cookie` 헤더 캐싱 시 주의가 필요하며, 캐시가 이 헤더를 제거하지 않도록 해야 합니다.
  * `Cookie` 헤더 포함 요청은 개인정보를 포함할 가능성이 있으므로, `must-revalidate`, `max-age=0` 설정을 통해 **재검사를 강제**하는 것이 좋습니다.

-----

### 쿠키와 보안, 개인정보

쿠키 자체보다는 **활용 방식**이 보안 이슈의 핵심입니다.

**원격 DB에 개인정보를 저장**하고 **키값만 쿠키로 관리**할 경우 안전성을 향상할 수 있습니다.

#### 보안 관련 고려사항

  * 협력업체의 지속 쿠키 사용은 **사용자 추적에 악용**될 가능성이 있습니다.
  * IP, `Referer` 등과 결합 시 **정확한 사용자 프로필 구축**이 가능합니다.
  * 개인정보 정책을 준수한다면 쿠키의 **편의성이 더 큰 장점**이 될 수 있습니다.
  * 쿠키는 시스템 보안 취약점을 악용할 수 없으며 웹 서버의 로그와 유사한 정보만 포함합니다.

----------------------

# 12장 기본인증

어떠한 웹 리소스에 권한을 부여해야 하는 상황에서, 수많은 사용자에게 각 역할에 맞는 리소스를 할당하기 위한 **인증**이 필요합니다.

### 인증의 개념

> 인증은 사용자가 **누구인지 증명하는 과정**입니다. HTTP는 자체적인 인증 요구/응답 프레임워크(기본, 다이제스트 등)를 제공합니다.

#### HTTP 인증 요구/응답 프레임워크

HTTP 인증은 다음과 같은 단계로 진행됩니다.

1.  **클라이언트가 보호된 리소스를 요청**합니다.
2.  **서버**가 `401 Unauthorized` 응답과 함께 **인증 요구**(`WWW-Authenticate` 헤더)를 보냅니다.
3.  **클라이언트**가 사용자 이름과 비밀번호를 수집하여 **`Authorization` 헤더와 함께 재요청**합니다.
4.  인증 성공 시 리소스를 제공하고, 실패 시 `401` 응답 또는 에러를 재전송합니다.

> **(참고: OAuth와 일반 HTTP 인증의 차이)**
>
> **OAuth**는 사용자가 자신의 인증 정보를 **제3자 클라이언트**에게 직접 제공하지 않고도, **리소스 서버**에 있는 보호된 리소스에 접근할 수 있도록 권한을 위임하는 **권한 부여(Authorization)** 프로토콜입니다.
>
> 반면, **HTTP 기본/다이제스트 인증**은 클라이언트가 **사용자 이름과 비밀번호**를 직접 제공하여 **자신임을 증명(Authentication)** 하는 전통적인 방식입니다. OAuth는 모바일 기기나 분산된 애플리케이션 환경에서 API 인증을 위해 사용되는 **현대의 권한 관리 표준**입니다.

#### 인증 관련 주요 헤더

  * **`WWW-Authenticate`**: **서버가 클라이언트에게** 인증 방식과 보안 영역(`realm`) 정보를 전달합니다.
  * **`Authorization`**: **클라이언트가 서버에게** 사용자 인증 정보를 전달합니다.
  * **`Authentication-Info`**: 인증 세션에 관한 추가 정보(선택적)입니다.

-----

### 보안 영역 (Realm)

보안 영역(`realm`)은 웹 서버가 기밀문서를 **논리적인 그룹**으로 묶는 방식이며, 각 영역마다 서로 다른 사용자 권한 체계를 적용합니다.

  * `realm` 파라미터는 사용자에게 **어떤 영역에 대한 인증**인지 설명합니다.
  * 동일 서버 내에서도 여러 보안 영역이 존재할 수 있습니다.
  * 사용자가 접근 권한의 범위를 이해하는 데 도움을 줍니다.

#### 보안 영역 활용 예시

웹 서버가 "Corporate Financials"와 "Family"라는 두 개의 보안 영역을 가질 경우,

  * CEO는 "Corporate Financials" 영역에만 접근 가능하고, 개인 가족 문서가 있는 "Family" 영역에는 접근 권한이 없을 수 있습니다.

#### `realm` 파라미터 활용

`WWW-Authenticate` 헤더에 `realm` 파라미터를 포함하여 사용자에게 정보를 제공합니다.

```
HTTP/1.0 401 Unauthorized
WWW-Authenticate: Basic realm="Corporate Financials"
```

  * `realm` 값은 해설 형식으로 사용자에게 어떤 권한 범위인지 명시합니다.
  * 사용자는 이 정보를 보고 **어떤 비밀번호를 사용해야 할지** 결정할 수 있습니다.

이러한 보안 영역 구조를 통해 웹 서버는 접근 권한을 세분화하여 관리하며, 사용자는 자신이 접근하려는 영역을 명확히 인지할 수 있습니다.

-----

### 기본 인증 메커니즘

\*\*기본 인증(Basic Authentication)\*\*은 가장 널리 알려진 HTTP 인증 규약으로, 구현이 단순하여 대부분의 주요 클라이언트와 서버에 구현되어 있습니다.

#### 기본 인증 절차/흐름

1.  **서버**가 `401` 상태 코드와 **`WWW-Authenticate`** 헤더(`Basic realm="..."`)로 인증을 요구합니다.
2.  **브라우저**가 사용자에게 사용자 이름과 비밀번호 입력 대화상자를 표시합니다.
3.  **브라우저**가 사용자 이름과 비밀번호를 **콜론으로 연결**하고 **Base-64로 인코딩**합니다.
4.  인코딩된 정보를 **`Authorization`** 헤더에 포함하여 재요청합니다.
5.  **서버**가 정보 검증 후 성공 시 요청된 리소스를 제공합니다.

#### Base-64 인코딩

Base-64 인코딩은 기본 인증에서 사용자 이름과 비밀번호를 전송하기 위한 방식입니다.

  * **8비트 바이트 시퀀스**를 **6비트 시퀀스**로 변환하여 64개의 알파벳 문자와 숫자를 사용해 표현합니다.
  * 국제 문자나 HTTP 헤더에서 사용할 수 없는 문자(콜론, 큰따옴표 등)를 안전하게 전송하기 위한 방식입니다.
  * **단순 인코딩일 뿐, 암호화는 아닙니다.** 우발적인 비밀번호 노출 방지에만 도움을 줍니다.

#### 프락시 인증

프락시 서버를 통한 인증도 가능하며, 회사 리소스 전체에 대한 통합적 접근 제어에 유용합니다. 웹 서버 인증과 유사하나 다른 헤더와 상태 코드를 사용합니다.

| 종류 | 상태 코드 | 인증 요구 헤더 | 인증 응답 헤더 |
| :--- | :--- | :--- | :--- |
| **웹 서버** | `401` | `WWW-Authenticate` | `Authorization` |
| **프락시 서버** | `407` | `Proxy-Authenticate` | `Proxy-Authorization` |

-----

### 기본 인증의 보안 결함

기본 인증은 구현이 단순하지만, 심각한 보안 결함이 존재하여 **중요한 데이터 보호에는 부적합**합니다.

| 결함 | 상세 설명 |
| :--- | :--- |
| **1. 쉽게 디코딩 가능한 전송 방식** | **Base-64 인코딩은 암호화가 아니므로**, 네트워크 트래픽 감시자(스니퍼)가 **쉽게 디코딩**하여 비밀번호를 획득할 수 있습니다. 사실상 **평문 전송과 다름없습니다**. |
| **2. 재전송 공격에 취약** | 공격자가 인코딩된 인증 정보를 캡처하여 \*\*그대로 재전송(재사용)\*\*할 수 있습니다. 재전송 공격을 방지하는 메커니즘이 전혀 구현되어 있지 않습니다. |
| **3. 사용자 습관으로 인한 추가 위험** | 사용자들이 여러 사이트에 **동일한 비밀번호를 사용**하는 경향이 있어, 중요하지 않은 사이트에서 획득한 인증 정보로 중요한 사이트에 접근할 위험이 있습니다. |
| **4. 메시지 변조 방지 기능 부재** | 인증 헤더 외의 **메시지 내용 변조를 감지할 수 없습니다**. 중개자가 메시지를 수정하여 트랜잭션의 본래 의도를 변경할 수 있습니다. |
| **5. 서버 위장 공격에 취약** | 가짜 서버가 인증 대화상자를 표시하여 사용자 인증 정보를 획득하는 **피싱 공격**에 취약합니다. 사용자는 진짜 서버에 연결되었다고 믿고 정보를 제공할 수 있습니다. |

#### 적절한 사용 상황 및 개선 방향

기본 인증은 **우연한 접근을 방지**하기 위한 기본적인 장벽이나, 중요하지 않은 정보 보호(개인 사진, 가족 문서 등)에 유용합니다.

중요한 데이터 보호를 위해서는 반드시 다음의 개선 방향을 따라야 합니다.

1.  **SSL/TLS와 함께 기본 인증 사용**: 통신 전체를 암호화하여 Base-64 인코딩 정보를 숨깁니다.
2.  **다이제스트 인증(Digest Authentication)** 같은 **더 강력한 인증 프로토콜**을 사용합니다.
3.  매우 민감한 데이터는 더 강력한 보안 시스템으로 보호해야 합니다.